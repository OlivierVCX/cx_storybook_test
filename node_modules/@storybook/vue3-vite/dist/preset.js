import CJS_COMPAT_NODE_URL_o0x6nzzn8bp from 'node:url';
import CJS_COMPAT_NODE_PATH_o0x6nzzn8bp from 'node:path';
import CJS_COMPAT_NODE_MODULE_o0x6nzzn8bp from "node:module";

var __filename = CJS_COMPAT_NODE_URL_o0x6nzzn8bp.fileURLToPath(import.meta.url);
var __dirname = CJS_COMPAT_NODE_PATH_o0x6nzzn8bp.dirname(__filename);
var require = CJS_COMPAT_NODE_MODULE_o0x6nzzn8bp.createRequire(import.meta.url);

// ------------------------------------------------------------
// end of CJS compatibility banner, injected by Storybook's esbuild configuration
// ------------------------------------------------------------
import {
  templateCompilation
} from "./_node-chunks/chunk-AGEPCA7C.js";
import {
  __name
} from "./_node-chunks/chunk-CCRFNFVA.js";

// src/plugins/vue-component-meta.ts
import { readFile, stat } from "node:fs/promises";
import { join, parse } from "node:path";
import { getProjectRoot } from "storybook/internal/common";
import MagicString from "magic-string";
import {
  TypeMeta,
  createChecker,
  createCheckerByJson
} from "vue-component-meta";
import { parseMulti } from "vue-docgen-api";
async function vueComponentMeta(tsconfigPath = "tsconfig.json") {
  const { createFilter } = await import("vite");
  const exclude = /\.stories\.(ts|tsx|js|jsx)$|^\0\/virtual:|^\/virtual:|\.storybook\/.*\.(ts|js)$/;
  const include = /\.(vue|ts|js|tsx|jsx)$/;
  const filter = createFilter(include, exclude);
  const checker = await createVueComponentMetaChecker(tsconfigPath);
  return {
    name: "storybook:vue-component-meta-plugin",
    async transform(src, id) {
      if (!filter(id)) {
        return void 0;
      }
      try {
        const exportNames = checker.getExportNames(id);
        let componentsMeta = exportNames.map((name) => checker.getComponentMeta(id, name));
        componentsMeta = await applyTempFixForEventDescriptions(id, componentsMeta);
        const metaSources = [];
        componentsMeta.forEach((meta, index) => {
          const isEmpty = !meta.props.length && !meta.events.length && !meta.slots.length && !meta.exposed.length;
          if (isEmpty || meta.type === TypeMeta.Unknown) {
            return;
          }
          const exportName = exportNames[index];
          ["props", "events", "slots", "exposed"].forEach((key) => {
            meta[key].forEach((value) => {
              if (Array.isArray(value.schema)) {
                value.schema.forEach((eventSchema) => removeNestedSchemas(eventSchema));
              } else {
                removeNestedSchemas(value.schema);
              }
            });
          });
          const exposed = (
            // the meta also includes duplicated entries in the "exposed" array with "on"
            // prefix (e.g. onClick instead of click), so we need to filter them out here
            meta.exposed.filter((expose) => {
              let nameWithoutOnPrefix = expose.name;
              if (nameWithoutOnPrefix.startsWith("on")) {
                nameWithoutOnPrefix = lowercaseFirstLetter(expose.name.replace("on", ""));
              }
              const hasEvent = meta.events.find((event) => event.name === nameWithoutOnPrefix);
              return !hasEvent;
            }).filter((expose) => {
              if (expose.name === "$slots") {
                const slotNames = meta.slots.map((slot) => slot.name);
                return !slotNames.every((slotName) => expose.type.includes(slotName));
              }
              return true;
            })
          );
          metaSources.push({
            exportName,
            displayName: exportName === "default" ? getFilenameWithoutExtension(id) : exportName,
            ...meta,
            exposed,
            sourceFiles: id
          });
        });
        if (metaSources.length === 0) {
          return void 0;
        }
        const s = new MagicString(src);
        metaSources.forEach((meta) => {
          const isDefaultExport = meta.exportName === "default";
          const name = isDefaultExport ? "_sfc_main" : meta.exportName;
          if (new RegExp(`export {.*${name}.*}`).test(src) || new RegExp(`export \\* from ['"]\\S*${name}['"]`).test(src) || // when using re-exports, some exports might be resolved via checker.getExportNames
          // but are not directly exported inside the current file so we need to ignore them too
          !src.includes(name)) {
            return;
          }
          if (!id.endsWith(".vue") && isDefaultExport) {
            s.replace("export default ", "const _sfc_main = ");
            s.append("\nexport default _sfc_main;");
          }
          s.append(`
;${name}.__docgenInfo = ${JSON.stringify(meta)}`);
        });
        return {
          code: s.toString(),
          map: s.generateMap({ hires: true, source: id })
        };
      } catch (e) {
        return void 0;
      }
    },
    // handle hot updates to update the component meta on file changes
    async handleHotUpdate({ file, read, server, modules, timestamp }) {
      const content = await read();
      checker.updateFile(file, content);
      const invalidatedModules = /* @__PURE__ */ new Set();
      for (const mod of modules) {
        server.moduleGraph.invalidateModule(mod, invalidatedModules, timestamp, true);
      }
      server.ws.send({ type: "full-reload" });
      return [];
    }
  };
}
__name(vueComponentMeta, "vueComponentMeta");
async function createVueComponentMetaChecker(tsconfigPath = "tsconfig.json") {
  const checkerOptions = {
    forceUseTs: true,
    noDeclarations: true,
    printer: { newLine: 1 }
  };
  const projectRoot = getProjectRoot();
  const projectTsConfigPath = join(projectRoot, tsconfigPath);
  const defaultChecker = createCheckerByJson(projectRoot, { include: ["**/*"] }, checkerOptions);
  if (await fileExists(projectTsConfigPath)) {
    const references = await getTsConfigReferences(projectTsConfigPath);
    if (references.length > 0) {
      return defaultChecker;
    }
    return createChecker(projectTsConfigPath, checkerOptions);
  }
  return defaultChecker;
}
__name(createVueComponentMetaChecker, "createVueComponentMetaChecker");
function getFilenameWithoutExtension(filename) {
  return parse(filename).name;
}
__name(getFilenameWithoutExtension, "getFilenameWithoutExtension");
function lowercaseFirstLetter(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
}
__name(lowercaseFirstLetter, "lowercaseFirstLetter");
async function fileExists(fullPath) {
  try {
    await stat(fullPath);
    return true;
  } catch {
    return false;
  }
}
__name(fileExists, "fileExists");
async function applyTempFixForEventDescriptions(filename, componentMeta) {
  const hasEvents = componentMeta.some((meta) => meta.events.length);
  if (!hasEvents) {
    return componentMeta;
  }
  try {
    const parsedComponentDocs = await parseMulti(filename);
    componentMeta.map((meta, index) => {
      const eventsWithDescription = parsedComponentDocs[index].events;
      if (!meta.events.length || !eventsWithDescription?.length) {
        return meta;
      }
      meta.events = meta.events.map((event) => {
        const description = eventsWithDescription.find((i) => i.name === event.name)?.description;
        if (description) {
          event.description = description;
        }
        return event;
      });
      return meta;
    });
  } catch {
  }
  return componentMeta;
}
__name(applyTempFixForEventDescriptions, "applyTempFixForEventDescriptions");
async function getTsConfigReferences(tsConfigPath) {
  try {
    const content = JSON.parse(await readFile(tsConfigPath, "utf-8"));
    if (!("references" in content) || !Array.isArray(content.references)) {
      return [];
    }
    return content.references;
  } catch {
    return [];
  }
}
__name(getTsConfigReferences, "getTsConfigReferences");
function removeNestedSchemas(schema) {
  if (typeof schema !== "object") {
    return;
  }
  if (schema.kind === "enum") {
    schema.schema?.forEach((enumSchema) => removeNestedSchemas(enumSchema));
    return;
  }
  delete schema.schema;
}
__name(removeNestedSchemas, "removeNestedSchemas");

// src/plugins/vue-docgen.ts
import MagicString2 from "magic-string";
import { parse as parse2 } from "vue-docgen-api";
async function vueDocgen() {
  const { createFilter } = await import("vite");
  const include = /\.(vue)$/;
  const filter = createFilter(include);
  return {
    name: "storybook:vue-docgen-plugin",
    async transform(src, id) {
      if (!filter(id)) {
        return void 0;
      }
      const metaData = await parse2(id);
      const s = new MagicString2(src);
      s.append(`;_sfc_main.__docgenInfo = ${JSON.stringify(metaData)}`);
      return {
        code: s.toString(),
        map: s.generateMap({ hires: true, source: id })
      };
    }
  };
}
__name(vueDocgen, "vueDocgen");

// src/preset.ts
var core = {
  builder: import.meta.resolve("@storybook/builder-vite"),
  renderer: import.meta.resolve("@storybook/vue3/preset")
};
var viteFinal = /* @__PURE__ */ __name(async (config, options) => {
  const plugins = [await templateCompilation()];
  const framework = await options.presets.apply("framework");
  const frameworkOptions = typeof framework === "string" ? {} : framework.options ?? {};
  const docgen = resolveDocgenOptions(frameworkOptions.docgen);
  if (docgen !== false) {
    if (docgen.plugin === "vue-component-meta") {
      plugins.push(await vueComponentMeta(docgen.tsconfig));
    } else {
      plugins.push(await vueDocgen());
    }
  }
  const { mergeConfig } = await import("vite");
  return mergeConfig(config, {
    plugins
  });
}, "viteFinal");
var resolveDocgenOptions = /* @__PURE__ */ __name((docgen) => {
  if (docgen === false) {
    return false;
  }
  if (docgen === void 0 || docgen === true) {
    return { plugin: "vue-docgen-api" };
  }
  if (typeof docgen === "string") {
    return { plugin: docgen };
  }
  return docgen;
}, "resolveDocgenOptions");
export {
  core,
  viteFinal
};
