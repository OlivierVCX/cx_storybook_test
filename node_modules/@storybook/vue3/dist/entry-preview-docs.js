import {
  __name
} from "./_browser-chunks/chunk-JFJ5UJ7Q.js";

// src/docs/sourceDecorator.ts
import { SourceType } from "storybook/internal/docs-tools";
import { emitTransformCode, useEffect } from "storybook/preview-api";
import { isVNode } from "vue";
var TRACKING_SYMBOL = Symbol("DEEP_ACCESS_SYMBOL");
var isProxy = /* @__PURE__ */ __name((obj) => !!(obj && typeof obj === "object" && TRACKING_SYMBOL in obj), "isProxy");
var sourceDecorator = /* @__PURE__ */ __name((storyFn, ctx) => {
  const story = storyFn();
  useEffect(() => {
    const sourceCode = generateSourceCode(ctx);
    if (shouldSkipSourceCodeGeneration(ctx)) {
      return;
    }
    emitTransformCode(sourceCode, ctx);
  });
  return story;
}, "sourceDecorator");
var generateSourceCode = /* @__PURE__ */ __name((ctx) => {
  const sourceCodeContext = {
    imports: {},
    scriptVariables: {}
  };
  const { displayName, slotNames, eventNames } = parseDocgenInfo(ctx.component);
  const props = generatePropsSourceCode(ctx.args, slotNames, eventNames, sourceCodeContext);
  const slotSourceCode = generateSlotSourceCode(ctx.args, slotNames, sourceCodeContext);
  const componentName = displayName || ctx.title.split("/").at(-1);
  const templateCode = slotSourceCode ? `<${componentName} ${props}> ${slotSourceCode} </${componentName}>` : `<${componentName} ${props} />`;
  const variablesCode = Object.entries(sourceCodeContext.scriptVariables).map(([name, value]) => `const ${name} = ${value};`).join("\n\n");
  const importsCode = Object.entries(sourceCodeContext.imports).map(([packageName, imports]) => {
    return `import { ${Array.from(imports.values()).sort().join(", ")} } from "${packageName}";`;
  }).join("\n");
  const template = `<template>
  ${templateCode}
</template>`;
  if (!importsCode && !variablesCode) {
    return template;
  }
  return `<script lang="ts" setup>
${importsCode ? `${importsCode}

${variablesCode}` : variablesCode}
<\/script>

${template}`;
}, "generateSourceCode");
var shouldSkipSourceCodeGeneration = /* @__PURE__ */ __name((context) => {
  const sourceParams = context?.parameters.docs?.source;
  if (sourceParams?.type === SourceType.DYNAMIC) {
    return false;
  }
  const isArgsStory = context?.parameters.__isArgsStory;
  return !isArgsStory || sourceParams?.code || sourceParams?.type === SourceType.CODE;
}, "shouldSkipSourceCodeGeneration");
var parseDocgenInfo = /* @__PURE__ */ __name((component) => {
  if (!component || !("__docgenInfo" in component) || !component.__docgenInfo || typeof component.__docgenInfo !== "object") {
    return {
      displayName: component?.__name,
      eventNames: [],
      slotNames: []
    };
  }
  const docgenInfo = component.__docgenInfo;
  const displayName = "displayName" in docgenInfo && typeof docgenInfo.displayName === "string" ? docgenInfo.displayName : void 0;
  const parseNames = /* @__PURE__ */ __name((key) => {
    if (!(key in docgenInfo) || !Array.isArray(docgenInfo[key])) {
      return [];
    }
    const values = docgenInfo[key];
    return values.map((i) => i && typeof i === "object" && "name" in i ? i.name : void 0).filter((i) => typeof i === "string");
  }, "parseNames");
  return {
    displayName: displayName || component.__name,
    slotNames: parseNames("slots").sort((a, b) => {
      if (a === "default") {
        return -1;
      }
      if (b === "default") {
        return 1;
      }
      return a.localeCompare(b);
    }),
    eventNames: parseNames("events")
  };
}, "parseDocgenInfo");
var generatePropsSourceCode = /* @__PURE__ */ __name((args, slotNames, eventNames, ctx) => {
  const properties = [];
  Object.entries(args).forEach(([propName, value]) => {
    if (slotNames.includes(propName)) {
      return;
    }
    if (value == void 0) {
      return;
    }
    if (isProxy(value)) {
      value = value.toString();
    }
    switch (typeof value) {
      case "string":
        if (value === "") {
          return;
        }
        properties.push({
          name: propName,
          value: value.includes('"') ? `'${value}'` : `"${value}"`,
          templateFn: /* @__PURE__ */ __name((name, propValue) => `${name}=${propValue}`, "templateFn")
        });
        break;
      case "number":
        properties.push({
          name: propName,
          value: value.toString(),
          templateFn: /* @__PURE__ */ __name((name, propValue) => `:${name}="${propValue}"`, "templateFn")
        });
        break;
      case "bigint":
        properties.push({
          name: propName,
          value: `BigInt(${value.toString()})`,
          templateFn: /* @__PURE__ */ __name((name, propValue) => `:${name}="${propValue}"`, "templateFn")
        });
        break;
      case "boolean":
        properties.push({
          name: propName,
          value: value ? "true" : "false",
          templateFn: /* @__PURE__ */ __name((name, propValue) => propValue === "true" ? name : `:${name}="false"`, "templateFn")
        });
        break;
      case "symbol":
        properties.push({
          name: propName,
          value: `Symbol(${value.description ? `'${value.description}'` : ""})`,
          templateFn: /* @__PURE__ */ __name((name, propValue) => `:${name}="${propValue}"`, "templateFn")
        });
        break;
      case "object": {
        properties.push({
          name: propName,
          value: formatObject(value ?? {}),
          // to follow Vue best practices, complex values like object and arrays are
          // usually placed inside the <script setup> block instead of inlining them in the <template>
          templateFn: void 0
        });
        break;
      }
      case "function":
        break;
    }
  });
  properties.sort((a, b) => a.name.localeCompare(b.name));
  const props = [];
  properties.forEach((prop) => {
    const isVModel = eventNames.includes(`update:${prop.name}`);
    if (!isVModel && prop.templateFn) {
      props.push(prop.templateFn(prop.name, prop.value));
      return;
    }
    let variableName = prop.name;
    if (variableName in ctx.scriptVariables) {
      let index = 1;
      do {
        variableName = `${prop.name}${index}`;
        index++;
      } while (variableName in ctx.scriptVariables);
    }
    if (!isVModel) {
      ctx.scriptVariables[variableName] = prop.value;
      props.push(`:${prop.name}="${variableName}"`);
      return;
    }
    ctx.scriptVariables[variableName] = `ref(${prop.value})`;
    if (!ctx.imports.vue) {
      ctx.imports.vue = /* @__PURE__ */ new Set();
    }
    ctx.imports.vue.add("ref");
    if (prop.name === "modelValue") {
      props.push(`v-model="${variableName}"`);
    } else {
      props.push(`v-model:${prop.name}="${variableName}"`);
    }
  });
  return props.join(" ");
}, "generatePropsSourceCode");
var generateSlotSourceCode = /* @__PURE__ */ __name((args, slotNames, ctx) => {
  const slotSourceCodes = [];
  slotNames.forEach((slotName) => {
    const arg = args[slotName];
    if (!arg) {
      return;
    }
    const slotContent = generateSlotChildrenSourceCode([arg], ctx);
    if (!slotContent) {
      return;
    }
    const slotBindings = typeof arg === "function" ? getFunctionParamNames(arg) : [];
    if (slotName === "default" && !slotBindings.length) {
      slotSourceCodes.push(slotContent);
    } else {
      slotSourceCodes.push(
        `<template ${slotBindingsToString(slotName, slotBindings)}>${slotContent}</template>`
      );
    }
  });
  return slotSourceCodes.join("\n\n");
}, "generateSlotSourceCode");
var generateSlotChildrenSourceCode = /* @__PURE__ */ __name((children, ctx) => {
  const slotChildrenSourceCodes = [];
  const generateSingleChildSourceCode = /* @__PURE__ */ __name((child) => {
    if (isVNode(child)) {
      return generateVNodeSourceCode(child, ctx);
    }
    switch (typeof child) {
      case "string":
      case "number":
      case "boolean":
        return child.toString();
      case "object":
        if (child === null) {
          return "";
        }
        if (Array.isArray(child)) {
          return child.map(generateSingleChildSourceCode).filter((code) => code !== "").join("\n");
        }
        return JSON.stringify(child);
      case "function": {
        const paramNames = getFunctionParamNames(child).filter(
          (param) => !["{", "}"].includes(param)
        );
        const parameters = {};
        const proxied = {};
        paramNames.forEach((param) => {
          parameters[param] = `{{ ${param} }}`;
          proxied[param] = new Proxy(
            {
              // we use the symbol to identify the proxy
              [TRACKING_SYMBOL]: true
            },
            {
              // getter is called when any prop of the parameter is read
              get: /* @__PURE__ */ __name((t, key) => {
                if (key === TRACKING_SYMBOL) {
                  return t[TRACKING_SYMBOL];
                }
                if ([Symbol.toPrimitive, Symbol.toStringTag, "toString"].includes(key)) {
                  return () => `{{ ${param} }}`;
                }
                if (key === "v-bind") {
                  return `${param}`;
                }
                return `{{ ${param}.${key.toString()} }}`;
              }, "get"),
              // ownKeys is called, among other uses, when an object is destructured
              // in this case we assume the parameter is supposed to be bound using "v-bind"
              // Therefore we only return one special key "v-bind" and the getter will be called afterwards with it
              ownKeys: /* @__PURE__ */ __name(() => {
                return [`v-bind`];
              }, "ownKeys"),
              /** Called when destructured */
              getOwnPropertyDescriptor: /* @__PURE__ */ __name(() => ({
                configurable: true,
                enumerable: true,
                value: param,
                writable: true
              }), "getOwnPropertyDescriptor")
            }
          );
        });
        const returnValue = child(proxied);
        const slotSourceCode = generateSlotChildrenSourceCode([returnValue], ctx);
        return slotSourceCode.replaceAll(/ (\S+)="{{ (\S+) }}"/g, ` :$1="$2"`);
      }
      case "bigint":
        return `{{ BigInt(${child.toString()}) }}`;
      // the only missing case here is "symbol"
      // because rendering a symbol as slot / HTML does not make sense and is not supported by Vue
      default:
        return "";
    }
  }, "generateSingleChildSourceCode");
  children.forEach((child) => {
    const sourceCode = generateSingleChildSourceCode(child);
    if (sourceCode !== "") {
      slotChildrenSourceCodes.push(sourceCode);
    }
  });
  return slotChildrenSourceCodes.join("\n");
}, "generateSlotChildrenSourceCode");
var generateVNodeSourceCode = /* @__PURE__ */ __name((vnode, ctx) => {
  const componentName = getVNodeName(vnode);
  let childrenCode = "";
  if (typeof vnode.children === "string") {
    childrenCode = vnode.children;
  } else if (Array.isArray(vnode.children)) {
    childrenCode = generateSlotChildrenSourceCode(vnode.children, ctx);
  } else if (vnode.children) {
    childrenCode = generateSlotSourceCode(
      vnode.children,
      // $stable is a default property in vnode.children so we need to filter it out
      // to not generate source code for it
      Object.keys(vnode.children).filter((i) => i !== "$stable"),
      ctx
    );
  }
  const props = vnode.props ? generatePropsSourceCode(vnode.props, [], [], ctx) : "";
  if (childrenCode) {
    return `<${componentName}${props ? ` ${props}` : ""}>${childrenCode}</${componentName}>`;
  }
  return `<${componentName}${props ? ` ${props}` : ""} />`;
}, "generateVNodeSourceCode");
var getVNodeName = /* @__PURE__ */ __name((vnode) => {
  if (typeof vnode.type === "string") {
    return vnode.type;
  }
  if (typeof vnode.type === "object") {
    if ("name" in vnode.type && vnode.type.name) {
      return vnode.type.name;
    } else if ("__name" in vnode.type && vnode.type.__name) {
      return vnode.type.__name;
    }
  }
  return "component";
}, "getVNodeName");
var getFunctionParamNames = /* @__PURE__ */ __name((func) => {
  const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
  const ARGUMENT_NAMES = /([^\s,]+)/g;
  const fnStr = func.toString().replace(STRIP_COMMENTS, "");
  const result = fnStr.slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")")).match(ARGUMENT_NAMES);
  if (!result) {
    return [];
  }
  return result.flatMap((param) => {
    if (["{", "}"].includes(param)) {
      return param;
    }
    const nonMinifiedName = param.split(":")[0].trim();
    if (nonMinifiedName.startsWith("{")) {
      return ["{", nonMinifiedName.substring(1)];
    }
    if (param.endsWith("}") && !nonMinifiedName.endsWith("}")) {
      return [nonMinifiedName, "}"];
    }
    return nonMinifiedName;
  });
}, "getFunctionParamNames");
var slotBindingsToString = /* @__PURE__ */ __name((slotName, params) => {
  if (!params.length) {
    return `#${slotName}`;
  }
  if (params.length === 1) {
    return `#${slotName}="${params[0]}"`;
  }
  return `#${slotName}="{ ${params.filter((i) => !["{", "}"].includes(i)).join(", ")} }"`;
}, "slotBindingsToString");
var formatObject = /* @__PURE__ */ __name((obj) => {
  const isPrimitive = Object.values(obj).every(
    (value) => value == null || typeof value !== "object"
  );
  if (isPrimitive) {
    return JSON.stringify(obj);
  }
  return JSON.stringify(obj, null, 2);
}, "formatObject");

// src/entry-preview-docs.ts
var decorators = [sourceDecorator];
export {
  decorators
};
